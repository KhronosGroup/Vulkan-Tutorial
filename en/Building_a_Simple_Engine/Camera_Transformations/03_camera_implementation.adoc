:pp: {plus}{plus}

= Camera & Transformations: Camera Implementation

== Camera Implementation

Now that we understand the mathematical foundations, let's implement a flexible camera system for our Vulkan application. We'll create a camera class that can be used to navigate our 3D scenes. This implementation is designed for a general-purpose 3D application or game engine, and the concepts can be applied to various types of applications, from first-person games to architectural visualization tools.

=== Camera Types

There are several types of cameras commonly used in 3D applications:

* *First-Person Camera*: Simulates viewing the world through the eyes of a character.
* *Third-Person Camera*: Follows a character from behind or another fixed relative position.
* *Orbit Camera*: Rotates around a fixed point, useful for object inspection.
* *Free Camera*: Allows unrestricted movement in all directions.

For our implementation, we'll focus on a versatile camera that can be configured for different use cases.

=== Camera Class Design

Let's design a camera class that encapsulates the necessary functionality:

[source,cpp]
----
class Camera {
private:
    // Camera position and orientation
    glm::vec3 position;
    glm::vec3 forward;
    glm::vec3 up;
    glm::vec3 right;
    glm::vec3 worldUp;

    // Euler angles
    float yaw;
    float pitch;

    // Camera options
    float movementSpeed;
    float mouseSensitivity;
    float zoom;
    float aspectRatio;
    float nearPlane;
    float farPlane;

    // Update camera vectors based on Euler angles
    void updateCameraVectors();

public:
    // Constructor with default values
    Camera(
        glm::vec3 position = glm::vec3(0.0f, 0.0f, 0.0f),
        glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f),
        float yaw = -90.0f,
        float pitch = 0.0f
    );

    // Get view matrix
    glm::mat4 getViewMatrix() const;

    // Get projection matrix
    glm::mat4 getProjectionMatrix() const;

    // Process camera movement (translation)
    void move(CameraMovement direction, float deltaTime);

    // Process camera rotation
    void rotate(float xOffset, float yOffset, bool constrainPitch = true);

    // Process zoom
    void zoom(float delta);

    // Getters for camera properties
    glm::vec3 getPosition() const { return position; }
    glm::vec3 getFront() const { return front; }
    float getZoom() const { return zoom; }
};
----

=== Camera Movement

We'll define an enum for camera movement directions:

[source,cpp]
----
enum class CameraMovement {
    FORWARD,
    BACKWARD,
    LEFT,
    RIGHT,
    UP,
    DOWN
};
----

And implement the movement logic:

[source,cpp]
----
void Camera::processKeyboard(CameraMovement direction, float deltaTime) {
    float velocity = movementSpeed * deltaTime;

    switch (direction) {
        case CameraMovement::FORWARD:
            position += front * velocity;
            break;
        case CameraMovement::BACKWARD:
            position -= front * velocity;
            break;
        case CameraMovement::LEFT:
            position -= right * velocity;
            break;
        case CameraMovement::RIGHT:
            position += right * velocity;
            break;
        case CameraMovement::UP:
            position += up * velocity;
            break;
        case CameraMovement::DOWN:
            position -= up * velocity;
            break;
    }
}
----

==== Handling Input Events

The camera class provides methods to process input, but you'll need to connect these to your application's input system. Here's how you might capture keyboard and mouse input using GLFW, (a common windowing library used with Vulkan):

[source,cpp]
----
// In your application's input handling function
void processInput(GLFWwindow* window, Camera& camera, float deltaTime) {
    // Keyboard input for camera movement
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
        camera.processKeyboard(CameraMovement::FORWARD, deltaTime);
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
        camera.processKeyboard(CameraMovement::BACKWARD, deltaTime);
    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
        camera.processKeyboard(CameraMovement::LEFT, deltaTime);
    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
        camera.processKeyboard(CameraMovement::RIGHT, deltaTime);
    if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS)
        camera.processKeyboard(CameraMovement::UP, deltaTime);
    if (glfwGetKey(window, GLFW_KEY_LEFT_CONTROL) == GLFW_PRESS)
        camera.processKeyboard(CameraMovement::DOWN, deltaTime);
}

// Mouse callback function for camera rotation
void mouseCallback(GLFWwindow* window, double xpos, double ypos) {
    static bool firstMouse = true;
    static float lastX = 0.0f, lastY = 0.0f;

    if (firstMouse) {
        lastX = xpos;
        lastY = ypos;
        firstMouse = false;
    }

    float xoffset = xpos - lastX;
    float yoffset = lastY - ypos; // Reversed: y ranges bottom to top

    lastX = xpos;
    lastY = ypos;

    // Pass the mouse movement to the camera
    camera.processMouseMovement(xoffset, yoffset);
}

// Scroll callback for zoom
void scrollCallback(GLFWwindow* window, double xoffset, double yoffset) {
    camera.processMouseScroll(yoffset);
}

// Setting up the callbacks in your initialization code
void setupInputCallbacks(GLFWwindow* window) {
    glfwSetCursorPosCallback(window, mouseCallback);
    glfwSetScrollCallback(window, scrollCallback);
    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // Capture mouse
}
----

[NOTE]
====
The specific implementation of input handling will depend on your windowing library and application architecture. The example above uses GLFW, but similar principles apply to other libraries like SDL, Qt, or platform-specific APIs. For more details on input handling with GLFW, refer to the https://www.glfw.org/docs/latest/input_guide.html[GLFW Input Guide].
====

=== Camera Rotation

For camera rotation, we'll use mouse input to adjust the yaw and pitch angles:

[source,cpp]
----
void Camera::processMouseMovement(float xOffset, float yOffset, bool constrainPitch) {
    xOffset *= mouseSensitivity;
    yOffset *= mouseSensitivity;

    yaw += xOffset;
    pitch += yOffset;

    // Constrain pitch to avoid flipping
    if (constrainPitch) {
        if (pitch > 89.0f)
            pitch = 89.0f;
        if (pitch < -89.0f)
            pitch = -89.0f;
    }

    // Update camera vectors based on updated Euler angles
    updateCameraVectors();
}
----

=== Updating Camera Vectors

After changing the camera's orientation, we need to recalculate the front, right, and up vectors:

[source,cpp]
----
void Camera::updateCameraVectors() {
    // Calculate the new front vector
    glm::vec3 newFront;
    newFront.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
    newFront.y = sin(glm::radians(pitch));
    newFront.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
    front = glm::normalize(newFront);

    // Recalculate the right and up vectors
    right = glm::normalize(glm::cross(front, worldUp));
    up = glm::normalize(glm::cross(right, front));
}
----

=== View Matrix

The view matrix transforms world coordinates into view coordinates (camera space):

[source,cpp]
----
glm::mat4 Camera::getViewMatrix() const {
    return glm::lookAt(position, position + front, up);
}
----

=== Projection Matrix

The projection matrix transforms view coordinates into clip coordinates:

[source,cpp]
----
glm::mat4 Camera::getProjectionMatrix(float aspectRatio, float nearPlane, float farPlane) const {
    return glm::perspective(glm::radians(zoom), aspectRatio, nearPlane, farPlane);
}
----

=== Advanced Topics: Third-Person Camera Implementation

In this section, we'll explore advanced techniques for implementing a third-person camera that follows a character while avoiding occlusion and maintaining focus on the character.

==== Third-Person Camera Design

A third-person camera typically needs to:

1. Follow the character at a specified distance
2. Maintain a consistent view of the character
3. Avoid being occluded by objects in the environment
4. Provide smooth transitions during movement and rotation

Let's extend our camera class to support these features:

[source,cpp]
----
class ThirdPersonCamera : public Camera {
private:
    // Target (character) properties
    glm::vec3 targetPosition;
    glm::vec3 targetForward;

    // Camera configuration
    float followDistance;
    float followHeight;
    float followSmoothness;

    // Occlusion avoidance
    float minDistance;
    float raycastDistance;

    // Internal state
    glm::vec3 desiredPosition;
    glm::vec3 smoothDampVelocity;

public:
    ThirdPersonCamera(
        float followDistance = 5.0f,
        float followHeight = 2.0f,
        float followSmoothness = 0.1f,
        float minDistance = 1.0f
    );

    // Update camera position based on target
    void updatePosition(const glm::vec3& targetPos, const glm::vec3& targetFwd, float deltaTime);

    // Handle occlusion avoidance
    void handleOcclusion(const Scene& scene);

    // Orbit around target
    void orbit(float horizontalAngle, float verticalAngle);

    // Setters for camera properties
    void setFollowDistance(float distance) { followDistance = distance; }
    void setFollowHeight(float height) { followHeight = height; }
    void setFollowSmoothness(float smoothness) { followSmoothness = smoothness; }
};
----

==== Character Following Algorithm

The core of a third-person camera is the algorithm that positions the camera relative to the character. Here's an implementation of the `updatePosition` method:

[source,cpp]
----
void ThirdPersonCamera::updatePosition(
    const glm::vec3& targetPos,
    const glm::vec3& targetFwd,
    float deltaTime
) {
    // Update target properties
    targetPosition = targetPos;
    targetForward = glm::normalize(targetFwd);

    // Calculate the desired camera position
    // Position the camera behind and above the character
    glm::vec3 offset = -targetForward * followDistance;
    offset.y = followHeight;

    desiredPosition = targetPosition + offset;

    // Smooth camera movement using exponential smoothing
    position = glm::mix(position, desiredPosition, 1.0f - pow(followSmoothness, deltaTime * 60.0f));

    // Update the camera to look at the target
    front = glm::normalize(targetPosition - position);

    // Recalculate right and up vectors
    right = glm::normalize(glm::cross(front, worldUp));
    up = glm::normalize(glm::cross(right, front));
}
----

This implementation:

1. Positions the camera behind the character based on the character's forward direction
2. Adds height to give a better view of the character and surroundings
3. Uses exponential smoothing to create natural camera movement
4. Always keeps the camera focused on the character

==== Occlusion Avoidance

One of the most challenging aspects of a third-person camera is handling occlusionâ€”when objects in the environment block the view of the character. Here's an implementation of occlusion avoidance:

[source,cpp]
----
void ThirdPersonCamera::handleOcclusion(const Scene& scene) {
    // Cast a ray from the target to the desired camera position
    Ray ray;
    ray.origin = targetPosition;
    ray.direction = glm::normalize(desiredPosition - targetPosition);

    // Check for intersections with scene objects
    RaycastHit hit;
    if (scene.raycast(ray, hit, glm::length(desiredPosition - targetPosition))) {
        // If there's an intersection, move the camera to the hit point
        // minus a small offset to avoid clipping
        float offsetDistance = 0.2f;
        position = hit.point - (ray.direction * offsetDistance);

        // Ensure we don't get too close to the target
        float currentDistance = glm::length(position - targetPosition);
        if (currentDistance < minDistance) {
            position = targetPosition + ray.direction * minDistance;
        }

        // Update the camera to look at the target
        front = glm::normalize(targetPosition - position);
        right = glm::normalize(glm::cross(front, worldUp));
        up = glm::normalize(glm::cross(right, front));
    }
}
----

This implementation:

1. Casts a ray from the character to the desired camera position
2. If the ray hits an object, moves the camera to the hit point (with a small offset)
3. Ensures the camera doesn't get too close to the character
4. Updates the camera orientation to maintain focus on the character

===== Performance Considerations for Occlusion Avoidance

When implementing occlusion avoidance, be mindful of performance:

* *Use simplified collision geometry*: For raycasting, use simpler collision shapes than your rendering geometry
* *Limit the frequency of occlusion checks*: You may not need to check every frame on slower devices
* *Consider spatial partitioning*: Use structures like octrees to speed up raycasts by quickly eliminating objects that can't possibly intersect with the ray
* *Optimize for mobile platforms*: For performance-constrained devices, consider simplifying the occlusion algorithm or reducing its precision

==== Implementing Orbit Controls

Many third-person games allow the player to orbit the camera around the character. Here's how to implement this functionality:

[source,cpp]
----
void ThirdPersonCamera::orbit(float horizontalAngle, float verticalAngle) {
    // Update yaw and pitch based on input
    yaw += horizontalAngle;
    pitch += verticalAngle;

    // Constrain pitch to avoid flipping
    if (pitch > 89.0f)
        pitch = 89.0f;
    if (pitch < -89.0f)
        pitch = -89.0f;

    // Calculate the new camera position based on spherical coordinates
    float radius = followDistance;
    float yawRad = glm::radians(yaw);
    float pitchRad = glm::radians(pitch);

    // Convert spherical coordinates to Cartesian
    glm::vec3 offset;
    offset.x = radius * cos(yawRad) * cos(pitchRad);
    offset.y = radius * sin(pitchRad);
    offset.z = radius * sin(yawRad) * cos(pitchRad);

    // Set the desired position
    desiredPosition = targetPosition + offset;

    // Update camera vectors
    front = glm::normalize(targetPosition - desiredPosition);
    right = glm::normalize(glm::cross(front, worldUp));
    up = glm::normalize(glm::cross(right, front));
}
----

This implementation:

1. Updates the camera's yaw and pitch based on user input
2. Constrains the pitch to prevent the camera from flipping
3. Calculates a new camera position using spherical coordinates
4. Keeps the camera focused on the character

==== Integrating with Character Movement

To create a complete third-person camera system, we need to integrate it with character movement. Here's an example of how to use the third-person camera in a game loop:

[source,cpp]
----
void gameLoop(float deltaTime) {
    // Update character position and orientation based on input
    character.update(deltaTime);

    // Update camera position to follow the character
    thirdPersonCamera.updatePosition(
        character.getPosition(),
        character.getForward(),
        deltaTime
    );

    // Handle camera occlusion
    thirdPersonCamera.handleOcclusion(scene);

    // Process camera orbit input (if any)
    if (mouseInputDetected) {
        thirdPersonCamera.orbit(mouseDeltaX, mouseDeltaY);
    }

    // Get the view and projection matrices for rendering
    glm::mat4 viewMatrix = thirdPersonCamera.getViewMatrix();
    glm::mat4 projMatrix = thirdPersonCamera.getProjectionMatrix(aspectRatio);

    // Use these matrices for rendering the scene
    renderer.render(scene, viewMatrix, projMatrix);
}
----

[NOTE]
====
For more advanced camera techniques, refer to the Advanced Camera Techniques section in the Appendix.
====

In the next section, we'll explore how to use transformation matrices to position objects in our 3D scene.

link:04_transformation_matrices.adoc[Next: Transformation Matrices]
