::pp: {plus}{plus}

= Mobile Development: Platform Considerations
:doctype: book
:sectnums:
:sectnumlevels: 4
:toc: left
:icons: font
:source-highlighter: highlightjs
:source-language: c++

== Platform Considerations for Android and iOS

Developing Vulkan applications for mobile platforms requires understanding the specific requirements and constraints of Android and iOS. In this section, we'll explore the key considerations for each platform and how to adapt your engine accordingly.

=== Android Platform Considerations

Android has supported Vulkan since version 7.0 (Nougat), but the level of support varies across devices. Here are the key considerations for Android development:

==== Setting Up Vulkan on Android

To use Vulkan on Android, you need to:

* *Declare Vulkan Support*: In your AndroidManifest.xml, declare that your
application uses Vulkan:

[source,xml]
----
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.vulkanapp">
    <uses-feature android:name="android.hardware.vulkan.version" android:version="0x400003" android:required="true" />
    <uses-feature android:name="android.hardware.vulkan.level" android:version="0" android:required="true" />
    <!-- For devices that support Vulkan but don't declare it -->
    <uses-feature android:name="android.hardware.vulkan.compute" android:required="false" />
    <!-- ... -->
</manifest>
----

* *Initialize Vulkan*: Use the Android Native Development Kit (NDK) to
initialize Vulkan. The process is similar to desktop Vulkan, but you'll need
 to obtain the native window handle from Android:

[source,cpp]
----
// Get the native window handle from Android
ANativeWindow* native_window = ANativeWindow_fromSurface(env, surface);

// Create the Vulkan surface
VkAndroidSurfaceCreateInfoKHR create_info{};
create_info.sType = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR;
create_info.window = native_window;

VkSurfaceKHR vulkan_surface;
vkCreateAndroidSurfaceKHR(instance, &create_info, nullptr, &vulkan_surface);
----

==== Android Lifecycle Management

Android applications have a complex lifecycle that you need to handle properly:

1. *Activity Pausing and Resuming*: When your application is paused (e.g., when the user switches to another app), you should release Vulkan resources and recreate them when the application resumes.

2. *Surface Changes*: The surface can change due to configuration changes (e.g., rotation). You need to handle these changes by recreating the swapchain.

3. *Memory Pressure*: Android can reclaim memory from your application at any time. Design your engine to handle memory pressure gracefully.

==== Android Input Handling

Android input handling differs from desktop:

1. *Touch Input*: Instead of mouse input, you'll need to handle touch events, including multi-touch gestures.

2. *Sensors*: Android devices have various sensors (accelerometer, gyroscope, etc.) that you can use for input.

==== Huawei Device Considerations

Huawei devices represent a significant portion of the Android market and have some specific considerations:

1. *HarmonyOS/EMUI*: Huawei's custom operating system is based on Android but has some differences. Test your application specifically on Huawei devices to ensure compatibility.

2. *Huawei GPU Turbo*: This technology optimizes GPU performance and power efficiency. Your Vulkan application can benefit from this, but you should test to ensure compatibility.

3. *AppGallery Distribution*: Since Huawei devices may not have Google Play Services, consider distributing your application through Huawei's AppGallery.

4. *Kirin SoCs*: Huawei's Kirin processors use Mali GPUs which are tile-based renderers. Optimize your rendering pipeline accordingly using the techniques described in the TBR section.

[source,cpp]
----
// Example of checking for Huawei devices
bool is_huawei_device(vk::PhysicalDevice physical_device) {
    vk::PhysicalDeviceProperties props = physical_device.getProperties();
    return props.vendorID == 0x19E5;  // Huawei vendor ID
}

// You can then apply Huawei-specific optimizations if needed
void configure_for_device(vk::PhysicalDevice physical_device) {
    if (is_huawei_device(physical_device)) {
        // Apply Huawei-specific optimizations
        // For example, you might want to use specific memory allocation strategies
        // or enable certain features that work well on Huawei's implementation
    }
}
----

=== iOS Platform Considerations

iOS supports Vulkan through MoltenVK, a translation layer that maps Vulkan to Metal. Here are the key considerations for iOS development:

==== Setting Up MoltenVK on iOS

To use Vulkan on iOS, you need to:

* *Include MoltenVK*: Add the MoltenVK framework to your Xcode project.

* *Initialize MoltenVK*: Initialize MoltenVK before creating your Vulkan
instance:

[source,cpp]
----
// Initialize MoltenVK
MVKConfiguration config{};
vkGetMoltenVKConfigurationMVK(nullptr, &config);
config.debugMode = true;  // Enable debug mode during development
vkSetMoltenVKConfigurationMVK(nullptr, &config);

// Create Vulkan instance as usual
// ...
----

* *Create a Metal-Compatible Surface*: Create a Vulkan surface from a
CAMetalLayer:

[source,cpp]
----
// Get the Metal layer from your UIView
CAMetalLayer* metal_layer = (CAMetalLayer*)layer;

// Create the Vulkan surface
VkMetalSurfaceCreateInfoEXT create_info{};
create_info.sType = VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT;
create_info.pLayer = metal_layer;

VkSurfaceKHR vulkan_surface;
vkCreateMetalSurfaceEXT(instance, &create_info, nullptr, &vulkan_surface);
----

==== iOS Lifecycle Management

iOS applications also have a lifecycle that you need to handle:

1. *Application State Changes*: Handle applicationWillResignActive, applicationDidBecomeActive, etc., by releasing and recreating Vulkan resources as needed.

2. *Memory Warnings*: iOS can send memory warnings when the system is low on memory. Handle these by releasing non-essential resources.

==== iOS Input Handling

iOS input handling is similar to Android but with some differences:

1. *Touch Input*: iOS has its own touch event system that you'll need to integrate with your engine.

2. *Sensors*: iOS devices also have various sensors that you can use for input.

=== Cross-Platform Considerations

To maintain a single codebase for both Android and iOS (and potentially desktop), consider:

* *Abstraction Layers*: Create platform-specific abstraction layers for
window creation, input handling, and other platform-specific functionality.

* *Conditional Compilation*: Use preprocessor directives to handle
platform-specific code:

[source,cpp]
----
#ifdef __ANDROID__
    // Android-specific code
#elif defined(__APPLE__)
    // iOS-specific code
#else
    // Desktop-specific code
#endif
----

* *Feature Detection*: Use Vulkan's feature detection mechanisms to adapt to
the capabilities of the device, rather than making assumptions based on the platform.

=== Best Practices for Mobile Platform Integration

1. *Test on Real Devices*: Emulators and simulators may not accurately represent the performance and behavior of real devices.

2. *Handle Different Screen Sizes and Aspect Ratios*: Mobile devices come in various sizes and aspect ratios. Design your UI and rendering to adapt accordingly.

3. *Consider Battery Life*: Mobile users are sensitive to battery drain. Optimize your engine to minimize power consumption.

4. *Respect Platform Guidelines*: Follow the design and user experience guidelines for each platform to ensure your application feels native.

In the next section, we'll explore performance optimizations specifically tailored for mobile hardware, focusing on texture formats and memory usage.

link:01_introduction.adoc[Previous: Introduction] | link:03_performance_optimizations.adoc[Next: Performance Optimizations for Mobile]
