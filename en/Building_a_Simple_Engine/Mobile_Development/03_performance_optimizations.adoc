:pp: {plus}{plus}

= Mobile Development: Performance Optimizations

== Performance Optimizations for Mobile

Mobile devices have significantly different hardware constraints compared to desktop systems. In this section, we'll explore key performance optimizations that are essential for achieving good performance on mobile platforms.

=== Texture Optimizations

To keep the workflow concrete and digestible, think of texture optimization in three steps:

1) Step 1: Ensure power‑of‑two (POT) dimensions (resize if needed)
2) Step 2: Pick a hardware‑compressed format supported by the device (ASTC → ETC2 → BC → fallback)
3) Step 3: Upload/update the Vulkan image and clean up staging resources

[NOTE]
====
We focus on mobile‑specific decisions here. For general Vulkan image creation, staging uploads, and descriptor setup, refer back to earlier chapters in the engine series—link:../Engine_Architecture/04_resource_management.adoc[Resource Management], link:../Engine_Architecture/05_rendering_pipeline.adoc[Rendering Pipeline]—or the Vulkan Guide (https://docs.vulkan.org/guide/latest/).
====

Textures are often the largest consumers of memory in a graphics application. Optimizing them is crucial for mobile performance.

==== Power-of-Two Textures

One of the most important optimizations for mobile is using power-of-two (POT) texture dimensions (e.g., 256x256, 512x1024, etc.). Here's why:

1. *Hardware Acceleration*: Most mobile GPUs are optimized for POT textures and can process them more efficiently.

2. *Mipmapping*: POT textures are required for proper mipmapping, which is essential for performance and visual quality.

3. *Memory Alignment*: POT textures align better with memory pages, improving memory access patterns.

To ensure your textures are POT, you can implement a texture loading system that automatically resizes non-POT textures:

[source,cpp]
----
vk::Extent2D make_power_of_two(uint32_t width, uint32_t height) {
    // Find the next power of two for each dimension
    uint32_t pot_width = 1;
    while (pot_width < width) pot_width *= 2;

    uint32_t pot_height = 1;
    while (pot_height < height) pot_height *= 2;

    return vk::Extent2D(pot_width, pot_height);
}

void load_texture(const std::string& path) {
    // Load the image data
    int width, height, channels;
    stbi_uc* pixels = stbi_load(path.c_str(), &width, &height, &channels, STBI_rgb_alpha);

    if (!pixels) {
        throw std::runtime_error("Failed to load texture image: " + path);
    }

    // Check if the dimensions are power of two
    bool is_pot = (width & (width - 1)) == 0 && (height & (height - 1)) == 0;

    if (!is_pot) {
        // Resize to power of two
        vk::Extent2D pot_size = make_power_of_two(width, height);

        stbi_uc* resized_pixels = new stbi_uc[pot_size.width * pot_size.height * 4];
        stbir_resize_uint8(pixels, width, height, 0,
                          resized_pixels, pot_size.width, pot_size.height, 0, 4);

        stbi_image_free(pixels);
        pixels = resized_pixels;
        width = pot_size.width;
        height = pot_size.height;
    }

    // Create Vulkan image and upload pixels
    // ...

    // Free the pixel data
    stbi_image_free(pixels);
}
----

==== Efficient Texture Formats

Choosing the right texture format is crucial for mobile performance:

1. *Compressed Formats*: Use hardware-supported compressed formats whenever possible:
   - *ASTC* (Adaptive Scalable Texture Compression): Widely supported on modern mobile GPUs, offers excellent quality-to-size ratio with flexible block sizes.
   - *ETC2/EAC*: Required for OpenGL ES 3.0 and supported by most Android devices.
   - *PVRTC*: Primarily supported on iOS devices with PowerVR GPUs.
   - *BC* (Block Compression): More common on desktop but supported by some high-end mobile GPUs.

2. *Format Selection Based on Content*: Choose formats based on the type of texture:
   - Use ASTC 4x4 or 6x6 for normal maps and detailed textures.
   - Use ASTC 8x8 or 12x12 for diffuse/albedo textures.
   - Consider using R8 for single-channel textures like height maps.

Here's how to check for and use compressed formats in Vulkan:

[source,cpp]
----
bool is_format_supported(vk::PhysicalDevice physical_device, vk::Format format, vk::ImageTiling tiling,
                        vk::FormatFeatureFlags features) {
    vk::FormatProperties props = physical_device.getFormatProperties(format);

    if (tiling == vk::ImageTiling::eLinear) {
        return (props.linearTilingFeatures & features) == features;
    } else if (tiling == vk::ImageTiling::eOptimal) {
        return (props.optimalTilingFeatures & features) == features;
    }

    return false;
}

vk::Format find_supported_format(vk::PhysicalDevice physical_device,
                               const std::vector<vk::Format>& candidates,
                               vk::ImageTiling tiling,
                               vk::FormatFeatureFlags features) {
    for (vk::Format format : candidates) {
        if (is_format_supported(physical_device, format, tiling, features)) {
            return format;
        }
    }

    throw std::runtime_error("Failed to find supported format");
}

vk::Format find_best_compressed_format(vk::PhysicalDevice physical_device) {
    // Try ASTC formats first (best quality-to-size ratio)
    std::vector<vk::Format> astc_formats = {
        vk::Format::eAstc8x8SrgbBlock,
        vk::Format::eAstc6x6SrgbBlock,
        vk::Format::eAstc4x4SrgbBlock
    };

    try {
        return find_supported_format(
            physical_device,
            astc_formats,
            vk::ImageTiling::eOptimal,
            vk::FormatFeatureFlagBits::eSampledImage
        );
    } catch (const std::runtime_error&) {
        // ASTC not supported, try ETC2
    }

    std::vector<vk::Format> etc2_formats = {
        vk::Format::eEtc2R8G8B8A8SrgbBlock,
        vk::Format::eEtc2R8G8B8SrgbBlock
    };

    try {
        return find_supported_format(
            physical_device,
            etc2_formats,
            vk::ImageTiling::eOptimal,
            vk::FormatFeatureFlagBits::eSampledImage
        );
    } catch (const std::runtime_error&) {
        // ETC2 not supported, try BC
    }

    std::vector<vk::Format> bc_formats = {
        vk::Format::eBc7SrgbBlock,
        vk::Format::eBc3SrgbBlock,
        vk::Format::eBc1SrgbBlock
    };

    try {
        return find_supported_format(
            physical_device,
            bc_formats,
            vk::ImageTiling::eOptimal,
            vk::FormatFeatureFlagBits::eSampledImage
        );
    } catch (const std::runtime_error&) {
        // Fall back to uncompressed
        return vk::Format::eR8G8B8A8Srgb;
    }
}
----

=== Memory Optimizations

Memory is a precious resource on mobile devices. Here are some key optimizations:

==== Minimize Memory Allocations

1. *Pool Allocations*: Use memory pools to reduce the overhead of frequent allocations and deallocations.

2. *Suballocate from Larger Blocks*: Instead of creating many small Vulkan memory allocations, allocate larger blocks and suballocate from them:

[source,cpp]
----
class VulkanMemoryPool {
public:
    VulkanMemoryPool(vk::Device device, vk::PhysicalDevice physical_device,
                    vk::DeviceSize block_size, uint32_t memory_type_index)
        : device(device), block_size(block_size), memory_type_index(memory_type_index) {
        allocate_new_block();
    }

    ~VulkanMemoryPool() {
        for (auto& block : memory_blocks) {
            device.freeMemory(block.memory);
        }
    }

    struct Allocation {
        vk::DeviceMemory memory;
        vk::DeviceSize offset;
        vk::DeviceSize size;
    };

    Allocation allocate(vk::DeviceSize size, vk::DeviceSize alignment) {
        // Find a block with enough space
        for (auto& block : memory_blocks) {
            vk::DeviceSize aligned_offset = align(block.next_offset, alignment);
            if (aligned_offset + size <= block_size) {
                Allocation alloc;
                alloc.memory = block.memory;
                alloc.offset = aligned_offset;
                alloc.size = size;

                block.next_offset = aligned_offset + size;
                return alloc;
            }
        }

        // No block has enough space, allocate a new one
        allocate_new_block();
        return allocate(size, alignment);  // Try again with the new block
    }

private:
    struct MemoryBlock {
        vk::DeviceMemory memory;
        vk::DeviceSize next_offset = 0;
    };

    void allocate_new_block() {
        vk::MemoryAllocateInfo alloc_info;
        alloc_info.setAllocationSize(block_size);
        alloc_info.setMemoryTypeIndex(memory_type_index);

        MemoryBlock block;
        block.memory = device.allocateMemory(alloc_info);
        block.next_offset = 0;

        memory_blocks.push_back(block);
    }

    vk::DeviceSize align(vk::DeviceSize offset, vk::DeviceSize alignment) {
        return (offset + alignment - 1) & ~(alignment - 1);
    }

    vk::Device device;
    vk::DeviceSize block_size;
    uint32_t memory_type_index;
    std::vector<MemoryBlock> memory_blocks;
};
----

==== Reduce Bandwidth Usage

1. *Minimize State Changes*: Group draw calls by material to reduce state changes.

2. *Use Smaller Data Types*: Use 16-bit indices and half-precision floats where appropriate.

3. *Optimize Vertex Formats*: Use packed vertex formats to reduce memory bandwidth:

[source,cpp]
----
// Traditional vertex format (48 bytes per vertex)
struct Vertex {
    glm::vec3 position;   // 12 bytes
    glm::vec3 normal;     // 12 bytes
    glm::vec2 texCoord;   // 8 bytes
    glm::vec4 color;      // 16 bytes
};

// Optimized vertex format (16 bytes per vertex)
struct OptimizedVertex {
    // Position: 3 components, 16-bit float each
    uint16_t position[3]; // 6 bytes

    // Normal: 2 components (can reconstruct Z), 8-bit signed normalized
    int8_t normal[2];     // 2 bytes

    // TexCoord: 2 components, 16-bit float each
    uint16_t texCoord[2]; // 4 bytes

    // Color: 4 components, 8-bit unsigned normalized
    uint8_t color[4];     // 4 bytes
};
----

=== Draw Call Optimizations

Mobile GPUs are particularly sensitive to draw call overhead:

1. *Instancing*: Use instancing to reduce draw calls for repeated objects.

2. *Batching*: Combine multiple objects into a single mesh where possible.

3. *Level of Detail (LOD)*: Implement LOD systems to reduce geometry complexity for distant objects.

=== Vendor-Specific Optimizations

Different mobile GPU vendors have specific architectures that may benefit from targeted optimizations.

==== Vendor-Specific GPU Optimizations

Different mobile GPU vendors have specific architectures that benefit from targeted optimizations:

* *GPU Technologies*: Many vendors implement custom GPU technologies to improve performance and power efficiency:
   - Maintain stable frame rates rather than pushing for maximum frames
   - Avoid unnecessary GPU state changes
   - Use efficient rendering techniques appropriate for the GPU architecture

* *Memory Management*: Many mobile SoCs have unified memory architecture:
   - Use `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` memory when possible
   - Take advantage of fast CPU-GPU memory transfers in unified memory architectures

* *Texture Compression*: Different devices support different texture
compression formats:

[source,cpp]
----
// Check for texture compression format support
bool supports_texture_format(vk::PhysicalDevice physical_device, vk::Format format) {
    vk::FormatProperties props = physical_device.getFormatProperties(format);
    return (props.optimalTilingFeatures & vk::FormatFeatureFlagBits::eSampledImage);
}

// Get optimal texture format based on device capabilities
vk::Format get_optimal_texture_format(vk::PhysicalDevice physical_device) {
    vk::PhysicalDeviceProperties props = physical_device.getProperties();
    vk::PhysicalDeviceFeatures features = physical_device.getFeatures();

    // Check for ASTC support (widely supported on modern mobile GPUs)
    if (features.textureCompressionASTC_LDR) {
        return vk::Format::eAstc8x8SrgbBlock;
    }

    // Check for vendor-specific optimizations
    // Huawei devices (Mali GPUs)
    if (props.vendorID == 0x19E5) {
        // Check for ETC2 support as fallback
        if (supports_texture_format(physical_device, vk::Format::eEtc2R8G8B8A8SrgbBlock)) {
            return vk::Format::eEtc2R8G8B8A8SrgbBlock;
        }
    }

    // Otherwise, fall back to the general format selection
    return find_best_compressed_format(physical_device);
}
----

* *Performance Monitoring*: Most vendors provide performance monitoring tools
 that can help identify bottlenecks specific to their hardware.

=== Best Practices for Mobile Performance

1. *Profile on Target Devices*: Performance characteristics vary widely across mobile devices. Test on a range of hardware from different manufacturers and with different GPU architectures.

2. *Monitor Temperature*: Mobile devices throttle performance when they get hot. Design your engine to adapt to thermal throttling.

3. *Balance Quality and Performance*: Provide graphics settings that allow users to balance quality and performance based on their device capabilities.

4. *Implement Adaptive Resolution*: Dynamically adjust rendering resolution based on performance metrics.

In the next section, we'll explore different rendering approaches for mobile GPUs, focusing on the differences between Tile-Based Rendering (TBR) and Immediate Mode Rendering (IMR).

link:02_platform_considerations.adoc[Previous: Platform Considerations] | link:04_rendering_approaches.adoc[Next: Rendering Approaches]
