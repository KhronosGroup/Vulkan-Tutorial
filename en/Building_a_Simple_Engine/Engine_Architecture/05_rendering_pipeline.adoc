:pp: {plus}{plus}

= Engine Architecture: Rendering Pipeline
:doctype: book
:sectnums:
:sectnumlevels: 4
:toc: left
:icons: font
:source-highlighter: highlightjs
:source-language: c++

== Rendering Pipeline

A well-designed rendering pipeline is essential for creating a flexible and efficient rendering engine. In this section, we'll explore how to structure your rendering pipeline to support various rendering techniques and effects.

=== Rendering Pipeline Challenges

When designing a rendering pipeline, you'll need to address several challenges:

1. *Flexibility* - Support different rendering techniques and effects.
2. *Performance* - Efficiently utilize the GPU and minimize state changes.
3. *Extensibility* - Allow for easy addition of new rendering features.
4. *Maintainability* - Keep the code organized and easy to understand.
5. *Platform Independence* - Abstract away platform-specific details.

=== Rendering Pipeline Architecture

A modern rendering pipeline typically consists of several stages:

1. *Scene Culling* - Determine which objects are visible and need to be rendered.
2. *Render Pass Management* - Organize rendering into passes with specific purposes.
3. *Command Generation* - Generate commands for the GPU to execute.
4. *Execution* - Submit commands to the GPU for execution.
5. *Post-Processing* - Apply effects to the rendered image.

Let's explore each of these stages in detail.

=== Scene Culling

Before rendering, we need to determine which objects are visible to the camera. This process is called culling and can significantly improve performance by reducing the number of objects that need to be rendered.

[source,cpp]
----
class CullingSystem {
private:
    Camera* camera;
    std::vector<Entity*> visibleEntities;

public:
    explicit CullingSystem(Camera* cam) : camera(cam) {}

    void SetCamera(Camera* cam) {
        camera = cam;
    }

    void CullScene(const std::vector<Entity*>& allEntities) {
        visibleEntities.clear();

        if (!camera) return;

        // Get camera frustum
        Frustum frustum = camera->GetFrustum();

        // Check each entity against the frustum
        for (auto entity : allEntities) {
            if (!entity->IsActive()) continue;

            auto meshComponent = entity->GetComponent<MeshComponent>();
            if (!meshComponent) continue;

            auto transformComponent = entity->GetComponent<TransformComponent>();
            if (!transformComponent) continue;

            // Get bounding box of the mesh
            BoundingBox boundingBox = meshComponent->GetBoundingBox();

            // Transform bounding box by entity transform
            boundingBox.Transform(transformComponent->GetTransformMatrix());

            // Check if bounding box is visible
            if (frustum.Intersects(boundingBox)) {
                visibleEntities.push_back(entity);
            }
        }
    }

    const std::vector<Entity*>& GetVisibleEntities() const {
        return visibleEntities;
    }
};
----

=== Render Pass Management

Modern rendering techniques often require multiple passes, each with a specific purpose. A render pass manager helps organize these passes and their dependencies.

In this tutorial, we use Vulkan's dynamic rendering feature with vk::raii instead of traditional render passes. Dynamic rendering simplifies the rendering process by allowing us to begin and end rendering operations with a single command, without explicitly creating VkRenderPass and VkFramebuffer objects. The vk::raii namespace provides Resource Acquisition Is Initialization (RAII) wrappers for Vulkan objects, which helps with resource management and makes the code cleaner. Additionally, our engine uses C++20 modules for better code organization, faster compilation times, and improved encapsulation.

=== Rendergraphs and Synchronization

A rendergraph is a higher-level abstraction that represents the entire rendering process as a directed acyclic graph (DAG), where nodes are render passes and edges represent dependencies between them. This approach offers several advantages over traditional render pass management:

==== What is a Rendergraph?

A rendergraph is a data structure that:

1. *Describes Resources*: Tracks all resources (textures, buffers) used in rendering.
2. *Defines Operations*: Specifies what operations (render passes) will be performed.
3. *Manages Dependencies*: Automatically determines the dependencies between operations.
4. *Handles Synchronization*: Automatically inserts necessary synchronization primitives.
5. *Optimizes Memory*: Can perform memory aliasing and other optimizations.

[source,cpp]
----
// A simple rendergraph class
class Rendergraph {
private:
    struct Resource {
        std::string name;
        vk::Format format;
        vk::Extent2D extent;
        vk::ImageUsageFlags usage;
        vk::ImageLayout initialLayout;
        vk::ImageLayout finalLayout;

        // The actual Vulkan resources
        vk::raii::Image image = nullptr;
        vk::raii::DeviceMemory memory = nullptr;
        vk::raii::ImageView view = nullptr;
    };

    struct Pass {
        std::string name;
        std::vector<std::string> inputs;  // Resources read by this pass
        std::vector<std::string> outputs; // Resources written by this pass
        std::function<void(vk::raii::CommandBuffer&)> executeFunc;
    };

    std::unordered_map<std::string, Resource> resources;
    std::vector<Pass> passes;
    std::vector<size_t> executionOrder; // Indices into passes

    // Synchronization objects
    std::vector<vk::raii::Semaphore> semaphores;
    std::vector<std::pair<size_t, size_t>> semaphoreSignalWaitPairs; // (signaling pass, waiting pass)

    vk::raii::Device& device;

public:
    explicit Rendergraph(vk::raii::Device& dev) : device(dev) {}

    // Add a resource to the rendergraph
    void AddResource(const std::string& name, vk::Format format, vk::Extent2D extent,
                    vk::ImageUsageFlags usage, vk::ImageLayout initialLayout,
                    vk::ImageLayout finalLayout) {
        Resource resource;
        resource.name = name;
        resource.format = format;
        resource.extent = extent;
        resource.usage = usage;
        resource.initialLayout = initialLayout;
        resource.finalLayout = finalLayout;

        resources[name] = resource;
    }

    // Add a pass to the rendergraph
    void AddPass(const std::string& name,
                const std::vector<std::string>& inputs,
                const std::vector<std::string>& outputs,
                std::function<void(vk::raii::CommandBuffer&)> executeFunc) {
        Pass pass;
        pass.name = name;
        pass.inputs = inputs;
        pass.outputs = outputs;
        pass.executeFunc = executeFunc;

        passes.push_back(pass);
    }

    // Compile the rendergraph
    void Compile() {
        // Build the dependency graph
        std::vector<std::vector<size_t>> dependencies(passes.size());
        std::vector<std::vector<size_t>> dependents(passes.size());

        // Map resources to the passes that write to them
        std::unordered_map<std::string, size_t> resourceWriters;

        // Find dependencies based on resource usage
        for (size_t i = 0; i < passes.size(); ++i) {
            const auto& pass = passes[i];

            // Check inputs
            for (const auto& input : pass.inputs) {
                auto it = resourceWriters.find(input);
                if (it != resourceWriters.end()) {
                    // This pass depends on the pass that writes to this resource
                    dependencies[i].push_back(it->second);
                    dependents[it->second].push_back(i);
                }
            }

            // Record outputs
            for (const auto& output : pass.outputs) {
                resourceWriters[output] = i;
            }
        }

        // Topological sort to determine execution order
        std::vector<bool> visited(passes.size(), false);
        std::vector<bool> inStack(passes.size(), false);
        std::function<void(size_t)> visit = [&](size_t node) {
            if (inStack[node]) {
                throw std::runtime_error("Cycle detected in rendergraph");
            }

            if (visited[node]) {
                return;
            }

            inStack[node] = true;

            for (auto dependent : dependents[node]) {
                visit(dependent);
            }

            inStack[node] = false;
            visited[node] = true;
            executionOrder.push_back(node);
        };

        for (size_t i = 0; i < passes.size(); ++i) {
            if (!visited[i]) {
                visit(i);
            }
        }

        // Create synchronization objects
        for (size_t i = 0; i < passes.size(); ++i) {
            for (auto dep : dependencies[i]) {
                // Create a semaphore for this dependency
                semaphores.emplace_back(device.createSemaphore({}));
                semaphoreSignalWaitPairs.emplace_back(dep, i);
            }
        }

        // Allocate actual resources
        for (auto& [name, resource] : resources) {
            // Create image
            vk::ImageCreateInfo imageInfo;
            imageInfo.setImageType(vk::ImageType::e2D)
                     .setFormat(resource.format)
                     .setExtent({resource.extent.width, resource.extent.height, 1})
                     .setMipLevels(1)
                     .setArrayLayers(1)
                     .setSamples(vk::SampleCountFlagBits::e1)
                     .setTiling(vk::ImageTiling::eOptimal)
                     .setUsage(resource.usage)
                     .setSharingMode(vk::SharingMode::eExclusive)
                     .setInitialLayout(vk::ImageLayout::eUndefined);

            resource.image = device.createImage(imageInfo);

            // Allocate memory
            vk::MemoryRequirements memRequirements = resource.image.getMemoryRequirements();

            vk::MemoryAllocateInfo allocInfo;
            allocInfo.setAllocationSize(memRequirements.size)
                     .setMemoryTypeIndex(FindMemoryType(memRequirements.memoryTypeBits,
                                                       vk::MemoryPropertyFlagBits::eDeviceLocal));

            resource.memory = device.allocateMemory(allocInfo);
            resource.image.bindMemory(*resource.memory, 0);

            // Create image view
            vk::ImageViewCreateInfo viewInfo;
            viewInfo.setImage(*resource.image)
                    .setViewType(vk::ImageViewType::e2D)
                    .setFormat(resource.format)
                    .setSubresourceRange({vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1});

            resource.view = device.createImageView(viewInfo);
        }
    }

    // Execute the rendergraph
    void Execute(vk::raii::CommandBuffer& commandBuffer, vk::Queue queue) {
        std::vector<vk::CommandBuffer> cmdBuffers;
        std::vector<vk::Semaphore> waitSemaphores;
        std::vector<vk::PipelineStageFlags> waitStages;
        std::vector<vk::Semaphore> signalSemaphores;

        // For each pass in the execution order
        for (auto passIdx : executionOrder) {
            const auto& pass = passes[passIdx];

            // Collect wait semaphores for this pass
            waitSemaphores.clear();
            waitStages.clear();

            for (size_t i = 0; i < semaphoreSignalWaitPairs.size(); ++i) {
                if (semaphoreSignalWaitPairs[i].second == passIdx) {
                    waitSemaphores.push_back(*semaphores[i]);
                    waitStages.push_back(vk::PipelineStageFlagBits::eColorAttachmentOutput);
                }
            }

            // Collect signal semaphores for this pass
            signalSemaphores.clear();

            for (size_t i = 0; i < semaphoreSignalWaitPairs.size(); ++i) {
                if (semaphoreSignalWaitPairs[i].first == passIdx) {
                    signalSemaphores.push_back(*semaphores[i]);
                }
            }

            // Begin command buffer
            commandBuffer.begin({});

            // Insert image memory barriers for layout transitions
            for (const auto& input : pass.inputs) {
                auto& resource = resources[input];

                vk::ImageMemoryBarrier barrier;
                barrier.setOldLayout(resource.initialLayout)
                       .setNewLayout(vk::ImageLayout::eShaderReadOnlyOptimal)
                       .setSrcQueueFamilyIndex(VK_QUEUE_FAMILY_IGNORED)
                       .setDstQueueFamilyIndex(VK_QUEUE_FAMILY_IGNORED)
                       .setImage(*resource.image)
                       .setSubresourceRange({vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1})
                       .setSrcAccessMask(vk::AccessFlagBits::eMemoryWrite)
                       .setDstAccessMask(vk::AccessFlagBits::eShaderRead);

                commandBuffer.pipelineBarrier(
                    vk::PipelineStageFlagBits::eAllCommands,
                    vk::PipelineStageFlagBits::eFragmentShader,
                    vk::DependencyFlagBits::eByRegion,
                    0, nullptr,
                    0, nullptr,
                    1, &barrier
                );
            }

            for (const auto& output : pass.outputs) {
                auto& resource = resources[output];

                vk::ImageMemoryBarrier barrier;
                barrier.setOldLayout(resource.initialLayout)
                       .setNewLayout(vk::ImageLayout::eColorAttachmentOptimal)
                       .setSrcQueueFamilyIndex(VK_QUEUE_FAMILY_IGNORED)
                       .setDstQueueFamilyIndex(VK_QUEUE_FAMILY_IGNORED)
                       .setImage(*resource.image)
                       .setSubresourceRange({vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1})
                       .setSrcAccessMask(vk::AccessFlagBits::eMemoryRead)
                       .setDstAccessMask(vk::AccessFlagBits::eColorAttachmentWrite);

                commandBuffer.pipelineBarrier(
                    vk::PipelineStageFlagBits::eAllCommands,
                    vk::PipelineStageFlagBits::eColorAttachmentOutput,
                    vk::DependencyFlagBits::eByRegion,
                    0, nullptr,
                    0, nullptr,
                    1, &barrier
                );
            }

            // Execute the pass
            pass.executeFunc(commandBuffer);

            // Insert image memory barriers for final layout transitions
            for (const auto& output : pass.outputs) {
                auto& resource = resources[output];

                vk::ImageMemoryBarrier barrier;
                barrier.setOldLayout(vk::ImageLayout::eColorAttachmentOptimal)
                       .setNewLayout(resource.finalLayout)
                       .setSrcQueueFamilyIndex(VK_QUEUE_FAMILY_IGNORED)
                       .setDstQueueFamilyIndex(VK_QUEUE_FAMILY_IGNORED)
                       .setImage(*resource.image)
                       .setSubresourceRange({vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1})
                       .setSrcAccessMask(vk::AccessFlagBits::eColorAttachmentWrite)
                       .setDstAccessMask(vk::AccessFlagBits::eMemoryRead);

                commandBuffer.pipelineBarrier(
                    vk::PipelineStageFlagBits::eColorAttachmentOutput,
                    vk::PipelineStageFlagBits::eAllCommands,
                    vk::DependencyFlagBits::eByRegion,
                    0, nullptr,
                    0, nullptr,
                    1, &barrier
                );
            }

            // End command buffer
            commandBuffer.end();

            // Submit command buffer
            vk::SubmitInfo submitInfo;
            submitInfo.setWaitSemaphoreCount(static_cast<uint32_t>(waitSemaphores.size()))
                      .setPWaitSemaphores(waitSemaphores.data())
                      .setPWaitDstStageMask(waitStages.data())
                      .setCommandBufferCount(1)
                      .setPCommandBuffers(&*commandBuffer)
                      .setSignalSemaphoreCount(static_cast<uint32_t>(signalSemaphores.size()))
                      .setPSignalSemaphores(signalSemaphores.data());

            queue.submit(1, &submitInfo, nullptr);
        }
    }

private:
    uint32_t FindMemoryType(uint32_t typeFilter, vk::MemoryPropertyFlags properties) {
        // Implementation to find suitable memory type
        // ...
        return 0; // Placeholder
    }
};
----

==== Vulkan Synchronization

Vulkan provides several synchronization primitives to ensure correct execution order and memory visibility:

1. *Semaphores*: Used for synchronization between queue operations (GPU-GPU synchronization).
2. *Fences*: Used for synchronization between CPU and GPU.
3. *Events*: Used for fine-grained synchronization within a command buffer.
4. *Barriers*: Used to synchronize access to resources and perform layout transitions.

Proper synchronization is crucial in Vulkan because:

1. *No Implicit Synchronization*: Unlike OpenGL, Vulkan doesn't provide implicit synchronization between operations.
2. *Parallel Execution*: Modern GPUs execute commands in parallel, which can lead to race conditions without proper synchronization.
3. *Memory Visibility*: Changes made by one operation may not be visible to another without proper barriers.

===== Pipeline Barriers

Pipeline barriers are one of the most important synchronization primitives in Vulkan. They ensure that operations before the barrier complete before operations after the barrier begin, and they can also perform layout transitions for images.

[source,cpp]
----
// Example of using a pipeline barrier for an image layout transition
void TransitionImageLayout(vk::raii::CommandBuffer& commandBuffer,
                          vk::Image image,
                          vk::Format format,
                          vk::ImageLayout oldLayout,
                          vk::ImageLayout newLayout) {
    vk::ImageMemoryBarrier barrier;
    barrier.setOldLayout(oldLayout)
           .setNewLayout(newLayout)
           .setSrcQueueFamilyIndex(VK_QUEUE_FAMILY_IGNORED)
           .setDstQueueFamilyIndex(VK_QUEUE_FAMILY_IGNORED)
           .setImage(image)
           .setSubresourceRange({vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1});

    vk::PipelineStageFlags sourceStage;
    vk::PipelineStageFlags destinationStage;

    if (oldLayout == vk::ImageLayout::eUndefined &&
        newLayout == vk::ImageLayout::eTransferDstOptimal) {
        barrier.setSrcAccessMask(vk::AccessFlagBits::eNone)
               .setDstAccessMask(vk::AccessFlagBits::eTransferWrite);

        sourceStage = vk::PipelineStageFlagBits::eTopOfPipe;
        destinationStage = vk::PipelineStageFlagBits::eTransfer;
    } else if (oldLayout == vk::ImageLayout::eTransferDstOptimal &&
               newLayout == vk::ImageLayout::eShaderReadOnlyOptimal) {
        barrier.setSrcAccessMask(vk::AccessFlagBits::eTransferWrite)
               .setDstAccessMask(vk::AccessFlagBits::eShaderRead);

        sourceStage = vk::PipelineStageFlagBits::eTransfer;
        destinationStage = vk::PipelineStageFlagBits::eFragmentShader;
    } else {
        throw std::invalid_argument("Unsupported layout transition!");
    }

    commandBuffer.pipelineBarrier(
        sourceStage, destinationStage,
        vk::DependencyFlagBits::eByRegion,
        0, nullptr,
        0, nullptr,
        1, &barrier
    );
}
----

===== Semaphores and Fences

Semaphores and fences are used for coarser-grained synchronization:

[source,cpp]
----
// Example of using semaphores and fences for queue synchronization
void RenderFrame(vk::raii::Device& device, vk::Queue graphicsQueue, vk::Queue presentQueue) {
    // Wait for the previous frame to finish
    vk::Result result = device.waitForFences(1, &*inFlightFence, VK_TRUE, UINT64_MAX);
    device.resetFences(1, &*inFlightFence);

    // Acquire the next image from the swapchain
    uint32_t imageIndex;
    result = device.acquireNextImageKHR(*swapchain, UINT64_MAX,
                                       *imageAvailableSemaphore, nullptr, &imageIndex);

    // Record command buffer
    // ...

    // Submit command buffer
    vk::SubmitInfo submitInfo;
    vk::PipelineStageFlags waitStages[] = {vk::PipelineStageFlagBits::eColorAttachmentOutput};
    submitInfo.setWaitSemaphoreCount(1)
              .setPWaitSemaphores(&*imageAvailableSemaphore)
              .setPWaitDstStageMask(waitStages)
              .setCommandBufferCount(1)
              .setPCommandBuffers(&*commandBuffer)
              .setSignalSemaphoreCount(1)
              .setPSignalSemaphores(&*renderFinishedSemaphore);

    graphicsQueue.submit(1, &submitInfo, *inFlightFence);

    // Present the image
    vk::PresentInfoKHR presentInfo;
    presentInfo.setWaitSemaphoreCount(1)
               .setPWaitSemaphores(&*renderFinishedSemaphore)
               .setSwapchainCount(1)
               .setPSwapchains(&*swapchain)
               .setPImageIndices(&imageIndex);

    result = presentQueue.presentKHR(&presentInfo);
}
----

==== How Rendergraphs Help with Synchronization

Rendergraphs simplify synchronization by:

1. *Automatic Dependency Tracking*: The rendergraph knows which passes depend on which resources, so it can automatically insert the necessary synchronization primitives.
2. *Optimal Barrier Placement*: The rendergraph can analyze the entire rendering process and place barriers only where needed, reducing overhead.
3. *Layout Transitions*: The rendergraph can automatically handle image layout transitions based on how resources are used.
4. *Resource Aliasing*: The rendergraph can reuse memory for resources that aren't used simultaneously, reducing memory usage.

===== Example: Implementing a Deferred Renderer with a Rendergraph

Here's how you might implement a deferred renderer using a rendergraph:

[source,cpp]
----
void SetupDeferredRenderer(Rendergraph& graph, uint32_t width, uint32_t height) {
    // Add resources
    graph.AddResource("GBuffer_Position", vk::Format::eR16G16B16A16Sfloat, {width, height},
                     vk::ImageUsageFlagBits::eColorAttachment | vk::ImageUsageFlagBits::eInputAttachment,
                     vk::ImageLayout::eUndefined, vk::ImageLayout::eShaderReadOnlyOptimal);

    graph.AddResource("GBuffer_Normal", vk::Format::eR16G16B16A16Sfloat, {width, height},
                     vk::ImageUsageFlagBits::eColorAttachment | vk::ImageUsageFlagBits::eInputAttachment,
                     vk::ImageLayout::eUndefined, vk::ImageLayout::eShaderReadOnlyOptimal);

    graph.AddResource("GBuffer_Albedo", vk::Format::eR8G8B8A8Unorm, {width, height},
                     vk::ImageUsageFlagBits::eColorAttachment | vk::ImageUsageFlagBits::eInputAttachment,
                     vk::ImageLayout::eUndefined, vk::ImageLayout::eShaderReadOnlyOptimal);

    graph.AddResource("Depth", vk::Format::eD32Sfloat, {width, height},
                     vk::ImageUsageFlagBits::eDepthStencilAttachment | vk::ImageUsageFlagBits::eInputAttachment,
                     vk::ImageLayout::eUndefined, vk::ImageLayout::eDepthStencilAttachmentOptimal);

    graph.AddResource("FinalColor", vk::Format::eR8G8B8A8Unorm, {width, height},
                     vk::ImageUsageFlagBits::eColorAttachment | vk::ImageUsageFlagBits::eTransferSrc,
                     vk::ImageLayout::eUndefined, vk::ImageLayout::eTransferSrcOptimal);

    // Add geometry pass
    graph.AddPass("GeometryPass",
                 {}, // No inputs
                 {"GBuffer_Position", "GBuffer_Normal", "GBuffer_Albedo", "Depth"},
                 [&](vk::raii::CommandBuffer& cmd) {
                     // Begin dynamic rendering
                     std::array<vk::RenderingAttachmentInfoKHR, 3> colorAttachments;

                     // Set up color attachments for G-buffer
                     // ...

                     // Set up depth attachment
                     // ...

                     vk::RenderingInfoKHR renderingInfo;
                     renderingInfo.setRenderArea({{0, 0}, {width, height}})
                                  .setLayerCount(1)
                                  .setColorAttachmentCount(colorAttachments.size())
                                  .setPColorAttachments(colorAttachments.data())
                                  .setPDepthAttachment(&depthAttachment);

                     cmd.beginRendering(renderingInfo);

                     // Bind pipeline and draw geometry
                     // ...

                     cmd.endRendering();
                 });

    // Add lighting pass
    graph.AddPass("LightingPass",
                 {"GBuffer_Position", "GBuffer_Normal", "GBuffer_Albedo", "Depth"},
                 {"FinalColor"},
                 [&](vk::raii::CommandBuffer& cmd) {
                     // Begin dynamic rendering
                     vk::RenderingAttachmentInfoKHR colorAttachment;
                     // Set up color attachment for final color
                     // ...

                     vk::RenderingInfoKHR renderingInfo;
                     renderingInfo.setRenderArea({{0, 0}, {width, height}})
                                  .setLayerCount(1)
                                  .setColorAttachmentCount(1)
                                  .setPColorAttachments(&colorAttachment);

                     cmd.beginRendering(renderingInfo);

                     // Bind pipeline and draw full-screen quad
                     // ...

                     cmd.endRendering();
                 });

    // Compile the rendergraph
    graph.Compile();
}
----

==== Best Practices for Rendergraphs and Synchronization

1. *Minimize Synchronization*: Use the rendergraph to minimize the number of synchronization points.
2. *Batch Similar Operations*: Group similar operations together to reduce state changes.
3. *Use Appropriate Access Flags*: Be specific about which access types you need to synchronize.
4. *Avoid Redundant Barriers*: Let the rendergraph eliminate redundant barriers.
5. *Consider Memory Aliasing*: Use the rendergraph's memory aliasing capabilities to reduce memory usage.
6. *Profile and Optimize*: Use GPU profiling tools to identify synchronization bottlenecks.
7. *Handle Platform Differences*: Different GPUs may have different synchronization requirements.

==== Benefits of Dynamic Rendering

Dynamic rendering offers several advantages over traditional render passes:

1. *Simplified API*: No need to create and manage VkRenderPass and VkFramebuffer objects, reducing code complexity.
2. *More Flexible Rendering*: Easier to change render targets and attachment formats at runtime.
3. *Improved Compatibility*: Works better with modern rendering techniques that don't fit well into the traditional render pass model.
4. *Reduced State Management*: Fewer objects to track and synchronize.
5. *Easier Debugging*: Simpler rendering code is easier to debug and maintain.

With dynamic rendering, we specify all rendering state (render targets, load/store operations, etc.) directly in the vkCmdBeginRendering call, rather than setting it up ahead of time in a VkRenderPass object. This allows for more dynamic rendering workflows and simplifies the implementation of techniques like deferred rendering.

[source,cpp]
----
// Forward declarations
class RenderPass;
class RenderTarget;

// Render pass manager
class RenderPassManager {
private:
    std::unordered_map<std::string, std::unique_ptr<RenderPass>> renderPasses;
    std::vector<RenderPass*> sortedPasses;
    bool dirty = true;

public:
    template<typename T, typename... Args>
    T* AddRenderPass(const std::string& name, Args&&... args) {
        static_assert(std::is_base_of<RenderPass, T>::value, "T must derive from RenderPass");

        auto it = renderPasses.find(name);
        if (it != renderPasses.end()) {
            return dynamic_cast<T*>(it->second.get());
        }

        auto pass = std::make_unique<T>(std::forward<Args>(args)...);
        T* passPtr = pass.get();
        renderPasses[name] = std::move(pass);
        dirty = true;

        return passPtr;
    }

    RenderPass* GetRenderPass(const std::string& name) {
        auto it = renderPasses.find(name);
        if (it != renderPasses.end()) {
            return it->second.get();
        }
        return nullptr;
    }

    void RemoveRenderPass(const std::string& name) {
        auto it = renderPasses.find(name);
        if (it != renderPasses.end()) {
            renderPasses.erase(it);
            dirty = true;
        }
    }

    void Execute(vk::raii::CommandBuffer& commandBuffer) {
        if (dirty) {
            SortPasses();
            dirty = false;
        }

        for (auto pass : sortedPasses) {
            pass->Execute(commandBuffer);
        }
    }

private:
    void SortPasses() {
        // Topologically sort render passes based on dependencies
        sortedPasses.clear();

        // Create a copy of render passes for sorting
        std::unordered_map<std::string, RenderPass*> passMap;
        for (const auto& [name, pass] : renderPasses) {
            passMap[name] = pass.get();
        }

        // Perform topological sort
        std::unordered_set<std::string> visited;
        std::unordered_set<std::string> visiting;

        for (const auto& [name, pass] : passMap) {
            if (visited.find(name) == visited.end()) {
                TopologicalSort(name, passMap, visited, visiting);
            }
        }
    }

    void TopologicalSort(const std::string& name,
                         const std::unordered_map<std::string, RenderPass*>& passMap,
                         std::unordered_set<std::string>& visited,
                         std::unordered_set<std::string>& visiting) {
        visiting.insert(name);

        auto pass = passMap.at(name);
        for (const auto& dep : pass->GetDependencies()) {
            if (visited.find(dep) == visited.end()) {
                if (visiting.find(dep) != visiting.end()) {
                    // Circular dependency detected
                    throw std::runtime_error("Circular dependency detected in render passes");
                }
                TopologicalSort(dep, passMap, visited, visiting);
            }
        }

        visiting.erase(name);
        visited.insert(name);
        sortedPasses.push_back(pass);
    }
};

// Base render pass class
class RenderPass {
private:
    std::string name;
    std::vector<std::string> dependencies;
    RenderTarget* target = nullptr;
    bool enabled = true;

public:
    explicit RenderPass(const std::string& passName) : name(passName) {}
    virtual ~RenderPass() = default;

    const std::string& GetName() const { return name; }

    void AddDependency(const std::string& dependency) {
        dependencies.push_back(dependency);
    }

    const std::vector<std::string>& GetDependencies() const {
        return dependencies;
    }

    void SetRenderTarget(RenderTarget* renderTarget) {
        target = renderTarget;
    }

    RenderTarget* GetRenderTarget() const {
        return target;
    }

    void SetEnabled(bool isEnabled) {
        enabled = isEnabled;
    }

    bool IsEnabled() const {
        return enabled;
    }

    virtual void Execute(vk::raii::CommandBuffer& commandBuffer) {
        if (!enabled) return;

        BeginPass(commandBuffer);
        Render(commandBuffer);
        EndPass(commandBuffer);
    }

protected:
    // With dynamic rendering, BeginPass typically calls vkCmdBeginRendering
    // instead of vkCmdBeginRenderPass
    virtual void BeginPass(vk::raii::CommandBuffer& commandBuffer) = 0;
    virtual void Render(vk::raii::CommandBuffer& commandBuffer) = 0;
    // With dynamic rendering, EndPass typically calls vkCmdEndRendering
    // instead of vkCmdEndRenderPass
    virtual void EndPass(vk::raii::CommandBuffer& commandBuffer) = 0;
};

// Render target class
class RenderTarget {
private:
    vk::raii::Image colorImage = nullptr;
    vk::raii::DeviceMemory colorMemory = nullptr;
    vk::raii::ImageView colorImageView = nullptr;

    vk::raii::Image depthImage = nullptr;
    vk::raii::DeviceMemory depthMemory = nullptr;
    vk::raii::ImageView depthImageView = nullptr;

    uint32_t width;
    uint32_t height;

public:
    RenderTarget(uint32_t w, uint32_t h) : width(w), height(h) {
        // Create color and depth images
        CreateColorResources();
        CreateDepthResources();

        // Note: With dynamic rendering, we don't need to create VkRenderPass
        // or VkFramebuffer objects. Instead, we just create the images and
        // image views that will be used directly with vkCmdBeginRendering.
    }

    // No need for explicit destructor with RAII objects

    vk::ImageView GetColorImageView() const { return *colorImageView; }
    vk::ImageView GetDepthImageView() const { return *depthImageView; }

    uint32_t GetWidth() const { return width; }
    uint32_t GetHeight() const { return height; }

private:
    void CreateColorResources() {
        // Implementation to create color image, memory, and view
        // With dynamic rendering, we just need to create the image and image view
        // that will be used with vkCmdBeginRendering
        // ...
    }

    void CreateDepthResources() {
        // Implementation to create depth image, memory, and view
        // With dynamic rendering, we just need to create the image and image view
        // that will be used with vkCmdBeginRendering
        // ...
    }

    vk::raii::Device& GetDevice() {
        // Get device from somewhere (e.g., singleton or parameter)
        // ...
        static vk::raii::Device device = nullptr; // Placeholder
        return device;
    }
};
----

=== Implementing Specific Render Passes

Now let's implement some specific render passes:

[source,cpp]
----
// Geometry pass for deferred rendering
class GeometryPass : public RenderPass {
private:
    CullingSystem* cullingSystem;

    // G-buffer textures
    RenderTarget* gBuffer;

public:
    GeometryPass(const std::string& name, CullingSystem* culling)
        : RenderPass(name), cullingSystem(culling) {
        // Create G-buffer render target
        gBuffer = new RenderTarget(1920, 1080); // Example resolution
        SetRenderTarget(gBuffer);
    }

    ~GeometryPass() override {
        delete gBuffer;
    }

protected:
    void BeginPass(vk::raii::CommandBuffer& commandBuffer) override {
        // Begin rendering with dynamic rendering
        vk::RenderingInfoKHR renderingInfo;

        // Set up color attachment
        vk::RenderingAttachmentInfoKHR colorAttachment;
        colorAttachment.setImageView(gBuffer->GetColorImageView())
                       .setImageLayout(vk::ImageLayout::eColorAttachmentOptimal)
                       .setLoadOp(vk::AttachmentLoadOp::eClear)
                       .setStoreOp(vk::AttachmentStoreOp::eStore)
                       .setClearValue(vk::ClearColorValue(std::array<float, 4>{0.0f, 0.0f, 0.0f, 1.0f}));

        // Set up depth attachment
        vk::RenderingAttachmentInfoKHR depthAttachment;
        depthAttachment.setImageView(gBuffer->GetDepthImageView())
                       .setImageLayout(vk::ImageLayout::eDepthStencilAttachmentOptimal)
                       .setLoadOp(vk::AttachmentLoadOp::eClear)
                       .setStoreOp(vk::AttachmentStoreOp::eStore)
                       .setClearValue(vk::ClearDepthStencilValue(1.0f, 0));

        // Configure rendering info
        renderingInfo.setRenderArea(vk::Rect2D({0, 0}, {gBuffer->GetWidth(), gBuffer->GetHeight()}))
                     .setLayerCount(1)
                     .setColorAttachmentCount(1)
                     .setPColorAttachments(&colorAttachment)
                     .setPDepthAttachment(&depthAttachment);

        // Begin dynamic rendering
        commandBuffer.beginRendering(renderingInfo);
    }

    void Render(vk::raii::CommandBuffer& commandBuffer) override {
        // Get visible entities
        const auto& visibleEntities = cullingSystem->GetVisibleEntities();

        // Render each entity to G-buffer
        for (auto entity : visibleEntities) {
            auto meshComponent = entity->GetComponent<MeshComponent>();
            auto transformComponent = entity->GetComponent<TransformComponent>();

            if (meshComponent && transformComponent) {
                // Bind pipeline for G-buffer rendering
                // ...

                // Set model matrix
                // ...

                // Draw mesh
                // ...
            }
        }
    }

    void EndPass(vk::raii::CommandBuffer& commandBuffer) override {
        // End dynamic rendering
        commandBuffer.endRendering();
    }
};

// Lighting pass for deferred rendering
class LightingPass : public RenderPass {
private:
    GeometryPass* geometryPass;
    std::vector<Light*> lights;

public:
    LightingPass(const std::string& name, GeometryPass* gPass)
        : RenderPass(name), geometryPass(gPass) {
        // Add dependency on geometry pass
        AddDependency(gPass->GetName());
    }

    void AddLight(Light* light) {
        lights.push_back(light);
    }

    void RemoveLight(Light* light) {
        auto it = std::find(lights.begin(), lights.end(), light);
        if (it != lights.end()) {
            lights.erase(it);
        }
    }

protected:
    void BeginPass(vk::raii::CommandBuffer& commandBuffer) override {
        // Begin rendering with dynamic rendering
        vk::RenderingInfoKHR renderingInfo;

        // Set up color attachment for the lighting pass
        vk::RenderingAttachmentInfoKHR colorAttachment;
        colorAttachment.setImageView(GetRenderTarget()->GetColorImageView())
                       .setImageLayout(vk::ImageLayout::eColorAttachmentOptimal)
                       .setLoadOp(vk::AttachmentLoadOp::eClear)
                       .setStoreOp(vk::AttachmentStoreOp::eStore)
                       .setClearValue(vk::ClearColorValue(std::array<float, 4>{0.0f, 0.0f, 0.0f, 1.0f}));

        // Configure rendering info
        renderingInfo.setRenderArea(vk::Rect2D({0, 0}, {GetRenderTarget()->GetWidth(), GetRenderTarget()->GetHeight()}))
                     .setLayerCount(1)
                     .setColorAttachmentCount(1)
                     .setPColorAttachments(&colorAttachment);

        // Begin dynamic rendering
        commandBuffer.beginRendering(renderingInfo);
    }

    void Render(vk::raii::CommandBuffer& commandBuffer) override {
        // Bind G-buffer textures from the geometry pass
        auto gBuffer = geometryPass->GetRenderTarget();

        // Set up descriptor sets for G-buffer textures
        // With dynamic rendering, we access the G-buffer textures directly as shader resources
        // rather than as subpass inputs

        // Render full-screen quad with lighting shader
        // ...

        // For each light
        for (auto light : lights) {
            // Set light properties
            // ...

            // Draw light volume
            // ...
        }
    }

    void EndPass(vk::raii::CommandBuffer& commandBuffer) override {
        // End dynamic rendering
        commandBuffer.endRendering();
    }
};

// Post-process effect base class
class PostProcessEffect {
public:
    virtual ~PostProcessEffect() = default;
    virtual void Apply(vk::raii::CommandBuffer& commandBuffer) = 0;
};

// Post-processing pass
class PostProcessPass : public RenderPass {
private:
    LightingPass* lightingPass;
    std::vector<PostProcessEffect*> effects;

public:
    PostProcessPass(const std::string& name, LightingPass* lPass)
        : RenderPass(name), lightingPass(lPass) {
        // Add dependency on lighting pass
        AddDependency(lPass->GetName());
    }

    void AddEffect(PostProcessEffect* effect) {
        effects.push_back(effect);
    }

    void RemoveEffect(PostProcessEffect* effect) {
        auto it = std::find(effects.begin(), effects.end(), effect);
        if (it != effects.end()) {
            effects.erase(it);
        }
    }

protected:
    void BeginPass(vk::raii::CommandBuffer& commandBuffer) override {
        // Begin rendering with dynamic rendering
        vk::RenderingInfoKHR renderingInfo;

        // Set up color attachment for the post-processing pass
        vk::RenderingAttachmentInfoKHR colorAttachment;
        colorAttachment.setImageView(GetRenderTarget()->GetColorImageView())
                       .setImageLayout(vk::ImageLayout::eColorAttachmentOptimal)
                       .setLoadOp(vk::AttachmentLoadOp::eClear)
                       .setStoreOp(vk::AttachmentStoreOp::eStore)
                       .setClearValue(vk::ClearColorValue(std::array<float, 4>{0.0f, 0.0f, 0.0f, 1.0f}));

        // Configure rendering info
        renderingInfo.setRenderArea(vk::Rect2D({0, 0}, {GetRenderTarget()->GetWidth(), GetRenderTarget()->GetHeight()}))
                     .setLayerCount(1)
                     .setColorAttachmentCount(1)
                     .setPColorAttachments(&colorAttachment);

        // Begin dynamic rendering
        commandBuffer.beginRendering(renderingInfo);
    }

    void Render(vk::raii::CommandBuffer& commandBuffer) override {
        // With dynamic rendering, each effect can set up its own rendering state
        // and access input textures directly as shader resources

        // Apply each post-process effect
        for (auto effect : effects) {
            effect->Apply(commandBuffer);
        }
    }

    void EndPass(vk::raii::CommandBuffer& commandBuffer) override {
        // End dynamic rendering
        commandBuffer.endRendering();
    }
};
----

=== Command Generation and Execution

Once we have our render passes set up, we need to generate and execute commands:

[source,cpp]
----
class Renderer {
private:
    vk::raii::Device device = nullptr;
    vk::Queue graphicsQueue;
    vk::raii::CommandPool commandPool = nullptr;

    RenderPassManager renderPassManager;
    CullingSystem cullingSystem;

    // Current frame resources
    vk::raii::CommandBuffer commandBuffer = nullptr;
    vk::raii::Fence fence = nullptr;
    vk::raii::Semaphore imageAvailableSemaphore = nullptr;
    vk::raii::Semaphore renderFinishedSemaphore = nullptr;

public:
    Renderer(vk::raii::Device& dev, vk::Queue queue) : device(dev), graphicsQueue(queue) {
        // Create command pool
        // ...

        // Create synchronization objects
        // ...

        // Set up render passes
        SetupRenderPasses();
    }

    // No need for explicit destructor with RAII objects

    void SetCamera(Camera* camera) {
        cullingSystem.SetCamera(camera);
    }

    void Render(const std::vector<Entity*>& entities) {
        // Wait for previous frame to finish
        fence.wait(UINT64_MAX);
        fence.reset();

        // Reset command buffer
        commandBuffer.reset();

        // Perform culling
        cullingSystem.CullScene(entities);

        // Record commands
        vk::CommandBufferBeginInfo beginInfo;
        commandBuffer.begin(beginInfo);

        // Execute render passes
        renderPassManager.Execute(commandBuffer);

        commandBuffer.end();

        // Submit command buffer
        vk::SubmitInfo submitInfo;

        // With vk::raii, we need to dereference the command buffer
        vk::CommandBuffer rawCommandBuffer = *commandBuffer;
        submitInfo.setCommandBufferCount(1);
        submitInfo.setPCommandBuffers(&rawCommandBuffer);

        // Set up wait and signal semaphores
        vk::PipelineStageFlags waitStages[] = { vk::PipelineStageFlagBits::eColorAttachmentOutput };

        // With vk::raii, we need to dereference the semaphores
        vk::Semaphore rawImageAvailableSemaphore = *imageAvailableSemaphore;
        vk::Semaphore rawRenderFinishedSemaphore = *renderFinishedSemaphore;

        submitInfo.setWaitSemaphoreCount(1);
        submitInfo.setPWaitSemaphores(&rawImageAvailableSemaphore);
        submitInfo.setPWaitDstStageMask(waitStages);
        submitInfo.setSignalSemaphoreCount(1);
        submitInfo.setPSignalSemaphores(&rawRenderFinishedSemaphore);

        // With vk::raii, we need to dereference the fence
        vk::Fence rawFence = *fence;
        graphicsQueue.submit(1, &submitInfo, rawFence);
    }

private:
    void SetupRenderPasses() {
        // Create geometry pass
        auto geometryPass = renderPassManager.AddRenderPass<GeometryPass>("GeometryPass", &cullingSystem);

        // Create lighting pass
        auto lightingPass = renderPassManager.AddRenderPass<LightingPass>("LightingPass", geometryPass);

        // Create post-process pass
        auto postProcessPass = renderPassManager.AddRenderPass<PostProcessPass>("PostProcessPass", lightingPass);

        // Add post-process effects
        // ...
    }
};
----

=== Advanced Rendering Techniques

==== Deferred Rendering

Deferred rendering separates the geometry and lighting calculations into separate passes, which can be more efficient for scenes with many lights:

1. *Geometry Pass* - Render scene geometry to G-buffer textures (position, normal, albedo, etc.).
2. *Lighting Pass* - Apply lighting calculations using G-buffer textures.

==== Forward+ Rendering

Forward+ (or tiled forward) rendering combines the simplicity of forward rendering with some of the efficiency benefits of deferred rendering:

1. *Light Culling Pass* - Divide the screen into tiles and determine which lights affect each tile.
2. *Forward Rendering Pass* - Render scene geometry with only the lights that affect each tile.

==== Physically Based Rendering (PBR)

PBR aims to create more realistic materials by simulating how light interacts with surfaces in the real world:

1. *Material Parameters* - Define materials using physically meaningful parameters (albedo, metalness, roughness, etc.).
2. *BRDF* - Use a physically based bidirectional reflectance distribution function.
3. *Image-Based Lighting* - Use environment maps for ambient lighting.

=== Conclusion

A well-designed rendering pipeline is essential for creating a flexible and efficient rendering engine. By implementing the techniques described in this section, you can create a system that:

1. Efficiently culls invisible objects
2. Organizes rendering into passes with clear dependencies
3. Supports advanced rendering techniques like deferred rendering and PBR
4. Can be easily extended with new effects and features

In the next section, we'll explore event systems, which provide a flexible way for different parts of your engine to communicate with each other.

link:04_resource_management.adoc[Previous: Resource Management] | link:06_event_systems.adoc[Next: Event Systems]
